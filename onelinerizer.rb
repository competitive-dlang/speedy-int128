#!/usr/bin/env ruby
#
# Convert D source file(s) into a single line of code.
#
# Copyright Â© 2023, Siarhei Siamashka
#
# Boost Software License - Version 1.0 - August 17th, 2003
#
# Permission is hereby granted, free of charge, to any person or organization
# obtaining a copy of the software and accompanying documentation covered by
# this license (the "Software") to use, reproduce, display, distribute,
# execute, and transmit the Software, and to prepare derivative works of the
# Software, and to permit third-parties to whom the Software is furnished to
# do so, all subject to the following:
#
# The copyright notices in the Software and this entire statement, including
# the above license grant, this restriction and the following disclaimer,
# must be included in all copies of the Software, in whole or in part, and
# all derivative works of the Software, unless such copies or derivative
# works are solely in the form of machine-executable object code generated by
# a source language processor.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
# SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
# FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.

require "json"
require "digest"

# This function "compiles" a D code snippet by trying to remove as many whitespaces as
# possible and producing a single line.
def preprocess_src(data)
  def remove_whitespaces(str)
    # test if there's a string literal
    if str =~ /(.*?)((\"\")|(\".*?[^\\]\"))(.*)/m
      part1 = $1
      string_literal = $2
      part2 = $5
      return remove_whitespaces(part1).strip + string_literal + remove_whitespaces(part2).strip
    else
      # collapse duplicate whitespaces
      str.gsub!(/\s+/m, " ")
      # collapse whitespaces around certain symbols
      str.gsub!(/\s*([\[\]\(\)\.\:\;\}\{\,\?])\s*/m, "\\1")
      # operators are a bit more tricky, because we don't want to convert "- -a" into "--a"
      op = '\>\<\=\+\-\*\/\|\&'
      str.gsub!(/([#{op}])\s+([^#{op}])/m, "\\1\\2")
      str.gsub!(/([^#{op}])\s+([#{op}])/m, "\\1\\2")
      return str
    end
  end

  # remove /* ... */ comments
  data.gsub!(/\/\*.*?\*\//m, " ")
  # remove /+ ... +/ comments
  data.gsub!(/\/\+.*?\+\//m, " ")
  # remove // ... comments
  data.gsub!(/\/\/.*?[\n\r]/m, " ")

  # remove redundant whitespaces
  data = remove_whitespaces(data).strip

  # remove the module declaration from the top
  if data =~ /^module\s+([^\;]+)\;(.*)$/m
    data = $2
    $first_module_name = $1.strip unless $first_module_name
  end

  # remove imports, except for imports from the standard library (prefixed by std/core/ldc/gdc)
  # strip the 'private'/'public'/'package' prefix because it is meaningles in a single file
  data.gsub!(/(private\s+|public\s+|package\s+)?(import\s+([^\;]+\;))/m) do
    import_part = $2
    module_name = $3
    if module_name =~ /^(std[\.\s\;\:]|core[\.\s\;\:]|ldc[\.\s\;\:]|gdc[\.\s\;\:])/
      import_part
    else
      ";"
    end
  end

  return data
end

# some tests
abort "test failed\n" unless preprocess_src("a + b") == "a+b"
abort "test failed\n" unless preprocess_src("- -a") == "- -a"
abort "test failed\n" unless preprocess_src("module x; import foobar;") == ";"
abort "test failed\n" unless preprocess_src("module x; import std : writeln;") == "import std:writeln;"

sources = []

# command line switches
$describe = false
$strip_unittests = false

if ARGV.size == 0
  puts("Usage: #{$PROGRAM_NAME} [--describe] [--strip-unittests] <list_of_D source_files_or_dub.json>")
  puts("Options:")
  puts("  --describe        : add comment with some extra information from git to the output.")
  puts("  --strip-unittests : remove unittests from the code for extra size reduction.")
  exit(0)
end

# process the command line
ARGV.each do |arg|
  if arg =~ /^\-\-(.*)/
    case $1
      when "describe" then $describe = true
      when "strip-unittests" then $strip_unittests = true
      else abort "Error: unknown option '--#{$1}'\n"
    end
  elsif arg =~ /dub\.json$/
    data = JSON.parse(File.read(arg))
    abort "bad json file #{arg}\n" unless data.has_key?("sourceFiles")
    data["sourceFiles"].each {|sourcefile| sources.push(File.join(File.dirname(arg), sourcefile)) }
  else
    sources.push(arg)
  end
end

$first_module_name = nil
onelinerized_source = sources.map {|filename| "version(all){" + preprocess_src(File.read(filename)) + "}"}.join("")

def strip_unittests(data)
  def delete_prefix_until_the_closing_curly_bracket(data)
    brackets_cnt = 1
    skip = true
    filtered_data = ""
    data.each_char do |ch|
      filtered_data += ch unless skip
      if ch == "{"
        brackets_cnt += 1
      elsif ch == "}"
        skip = false if (brackets_cnt -= 1) <= 0
      end
    end
    return filtered_data
  end

  # FIXME: string literals containing the "unittest" substring or curly
  # brackets may cause troubles here!

  # Handle "unittest { ... }". This is relatively simple.
  if data =~ /^(.*?)[^\;\}\{]*unittest\{(.*)$/m
    part1 = $1
    part2 = delete_prefix_until_the_closing_curly_bracket($2)
    return strip_unittests(part1 + part2)
  end

  # Handle "version(unittest) { ... }". Completely erasing it is too tricky,
  # because it may have an "else" branch too. So just substitute it
  # with "version(none){}" for now.
  if data =~ /^(|.*?\W)version\(unittest\)\{(.*)$/m
    part1 = $1
    part2 = delete_prefix_until_the_closing_curly_bracket($2)
    return strip_unittests(part1 + "version(none){}" + part2)
  end

  return data
end

onelinerized_source = strip_unittests(onelinerized_source) if $strip_unittests

prefix = ""
if $describe
  git_url = `git remote get-url origin`.strip
  if git_url =~ /^git\@github\.com\:(.*)\.git$/ || git_url =~ /^https\:\/\/github\.com\/(.*)\.git$/
    git_url = "https://github.com/" + $1
  end
  tag_describe = `git describe --tag --dirty`.strip
  if $first_module_name && tag_describe =~ /^v/
    prefix += "/* 'import #{$first_module_name};' #{tag_describe} from #{git_url} "
    prefix += "(size: #{onelinerized_source.size}, "
    prefix += "hash:#{Digest::SHA256.hexdigest(onelinerized_source)[0 .. 8]}) */ "
  else
    prefix += "/* code from #{git_url} (size: #{onelinerized_source.size}, "
    prefix += "hash:#{Digest::SHA256.hexdigest(onelinerized_source)[0 .. 8]}) */ "
  end
end

puts prefix + onelinerized_source
